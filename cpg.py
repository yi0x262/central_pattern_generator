#!/usr/env/bin python3
import numpy as np
from scipy.integrate import odeint

#Sustained Oscillations Generated by Mutually Inhibiting Neurons with Adaptation,Matsuoka,1985
class cpg(object):
    def __init__(self,num,A,b=2.5,T=12,x0=[0,0,0,0,0,0]):
        """
        A (const) : strengths of an inhibitory connection between neurons (i!=j:aij>0,i==j:aij=0)
        b (const) : time cources of adaptation (2.5)
        T (const) : time cources of adaptation (12)
        """
        self.A = np.array(A)
        self.g = np.tanh

        self.b = b
        self.T = T
        self.x = np.array(x0)
        self.num = num

    def __call__(self,t,s):
        """s:input vector"""
        self.x   = odeint(self.func,self.x,t,args=(s,))
        return self.x

    def func(self,vector,t,s):
        """
        x[0]: voltage
        t   :
        s   : input
        x[1]: output
        x'  : adaptation
        b,T : time cources of adaptation (scalar?)

        dx/dt   = -x - yA + s + bx'
        dx'/dt  = (-x' + y)/T
        y       = g(x)
        """
        x = np.hsplit(vector,3)
        ss = np.array(s)
        return np.r_[(-x[0]-np.dot(x[2],self.A)+ss+self.b*x[1]),(-x[1]+x[2])/self.T,self.g(x[0])]

if __name__ == '__main__':
    import matplotlib.pyplot as plt

    neuronum = 2
    times = 100
    A = [[0,2.5],[2.5,0]]
    c = cpg(neuronum,A,x0=[1,0,0,0,0,0])

    s = [0.,0.]
    t = np.linspace(0,10,10000001)
    y = c(t,s)
    #y = [d[2*neuronum:] for d in y]

    plt.plot(t,y)
    plt.show()
